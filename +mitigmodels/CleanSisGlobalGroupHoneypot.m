function [network_k1_cleaned, cleaned_devs, reset_devs, false_neg, false_pos]  = CleanSisGlobalGroupHoneypot(network, param)

% Initialize new matrix
network_k1_cleaned = network;

cleaned_devs = 0;
false_pos = 0;

switch param.malware
    
    case 'SIS'

        % The function below is NOT equivalent to a real device or process:
        % It just reads the actual number of infected devices in the
        % simulation and returns their address.
        count = 1;
        numberInfected = 0;
        addressInfected = [];
        for count=1:0.1*param.n:param.n
            if network(2,count)==1
                numberInfected = numberInfected +1;
                addressInfected = [adressInfected count];
            end
        end

        % The function below IS equivalent to a real device or process: It
        % simulates a detection system looking for infection in the devices
        % and failing in a percentage of cases according to param.beta, the
        % detection rate.  (For the sake of computational efficiency, I
        % just ran the FPR test for a number of times - same as number of
        % non-infected devices - and incremented the counter of cleaned
        % positives.)
        for dev_add=1:numberInfected
            if network(3,dev_add)==1 || rand(1)<=param.beta
                cleaned_devs = cleaned_devs + 1;
                network_k1_cleaned(3,addressInfected(dev_add)) = 0;
            end
        end
        false_neg = numberInfected - cleaned_devs;
        
        % The function below IS equivalent to a real device or process: It
        % simulates a detection system looking for infection in the devices
        % and generating false positives according to param.FPR. (For the
        % sake of computational efficiency, I just ran the FPR test for a
        % number of times - same as number of non-infected devices - and
        % incremented the counter of false positives.)
        for count=1:(param.n-numberInfected)
            if rand(1)<=param.FPR
                false_pos = false_pos + 1;
            end
        end
        
        reset_devs = (cleaned_devs+false_pos)*(param.G+1);
        
        if reset_devs<=param.n
        % Naturally, we expect that the designed number of resets in the
        % mass mitigation does not exceed the very number N of devices in
        % the network. I.O.W., that it doesn't saturate. In this normal
        % operation, do the following:
            group_m_devices = randperm(param.n, (cleaned_devs+false_pos)*param.G);
        else
        % In case it saturates, cap the resets at N.
            reset_devs = param.n;
            group_m_devices = randperm(param.n);
        end
        
        for j=1:length(group_m_devices)
            network_k1_cleaned(3,group_m_devices(j)) = 0;
        end

   
    case 'SIQ'
        
        
        [addressInfected, numberInfected] = GetSenderGlobalInfectedVector(network, 'SIQ');
        
        for dev_add=1:numberInfected
        
            if rand(1)<=param.beta
                cleaned_devs = cleaned_devs + 1;
                network_k1_cleaned(2,addressInfected(dev_add)) = 0;
                network_k1_cleaned(3,addressInfected(dev_add)) = 0;
            end

        end
        
        group_m_devices = randperm(param.n, cleaned_devs*param.G);
        
        for j=1:length(group_m_devices)
            network_k1_cleaned(2,group_m_devices(j)) = 0;
            network_k1_cleaned(3,group_m_devices(j)) = 0;
        end
end

%         numberInfected
%         cleaned_devs


end