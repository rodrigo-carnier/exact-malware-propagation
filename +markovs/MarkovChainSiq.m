function Pt_next = MarkovChainSiq(Pt, IR, DR, mode, N)
 
switch(mode)
    
    case 'linear'
        
        % Linear Model

        A = [-IR     DR;
            IR      -DR];
        
        dPt_next = A*Pt;
        
        Pt_next = Pt + dPt_next;

        
    case 'nonlinearmod'

        %% Non-linear Model similar to reference
        g = Pt(2) - Pt(1); % I-S
        e = Pt(1) - Pt(2); % S-I
        g_plus = g*(abs(g)-g)/(2*e);
        dPt = [(-IR*(g_plus + Pt(1)) + DR*Pt(2));
               ( IR*(g_plus + Pt(1)) - DR*Pt(2))];

        Pt_next = Pt + dPt;

        % Pt_next(1) = round(Pt_next(1));
        % Pt_next(2) = round(Pt_next(2));

             
    case 'nonlinear'

        %% Non-linear Model similar to reference

        dPt = [(-IR*Pt(1)*Pt(2) + DR*Pt(2));
                (IR*Pt(1)*Pt(2) - DR*Pt(2))];

        Pt_next = Pt + dPt;

        % Pt_next(1) = round(Pt_next(1));
        % Pt_next(2) = round(Pt_next(2));

    case 'combinatory3rd'
        SecondTerm = IR*(Pt(1)*Pt(2));
        ThirdFactorial = nchoosek(round(Pt(2)*N),2);
        ThirdTerm = ThirdFactorial*Pt(1)/N^2;
        Pt_next = [(Pt(1) - SecondTerm + ThirdTerm     + DR*Pt(2));
               (        SecondTerm - ThirdTerm     + Pt(2) - DR*Pt(2))];

           
    case 'combinatoryExact'

% % All three functions active        
        F = Pt(1) - Pt(1)*((1 - (IR/N))^(Pt(2)*N));
%         F = Pt(1) - Pt(1)*((1 - (IR/N))^((Pt(2)-Pt(3))*N));        
        dPt = [(- F);
               (  F - DR*Pt(2));
			   DR*Pt(2)];

  
% % Only attack.
%         F = Pt(1) - Pt(1)*((1 - (IR/N))^(Pt(2)*N));
%         dPt = [(- F);
%                (  F);
% 			   0];

% % Only detection and quarantine. It works identically to simulation (same graphics)
%         dPt = [0;
%               -DR*Pt(2);
% 			  DR*Pt(2)];

           
        Pt_next = Pt + dPt;
		
    case 'onlyir'
        
%         dPt = [(-IR*(Pt(2) + Pt(1)) + DR*Pt(2));
%                ( IR*(Pt(2) + Pt(1)) - DR*Pt(2))];
        dPt = [(-IR*Pt(2)*Pt(1));
                (IR*Pt(2)*Pt(1))];

        Pt_next = Pt + dPt;
        
    case 'onlydr'
        
        dPt = [(DR*Pt(2));
                (- DR*Pt(2))];

        Pt_next = Pt + dPt;
        


end

end
