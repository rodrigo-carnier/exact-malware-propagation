clear all;

%% Initialize parameters and objects

initParam;
param.malware = 'SIS';

% Initialize matrix of states: initGlobalXXX creates and populates a matrix
% with the states of every device in the network. Meaning of each line in
% the matrix:
% 
% (1,i) Address of device. The address is a decimal number from 1 to n
% (2,i) Powered or not. 0 - device is turned off. 1 - device is turned on. -1 - device is turned off but will be reset next turn.
% (3,i) MSM Infected or not. 0 - not MSM infected. 1 - devices's MSM is infected.
% (4,i) ACM Infected or not. 0 - not ACM infected. 1 - devices's ACM is infected.

switch param.malware
    case 'SIS'
        inits.InitSisGlobal;
    case 'SIQ'
        inits.InitSiqGlobal;
    case 'SEIRS'
        inits.InitSeirsGlobal;
end




% Initialize reports:
%
% The matrix below is a report generated every turn about the situation of
% the network in terms of infection, device on or off.
% Every line represents a turn. The meaning of each column is:

% (:,1) Turn
% (:,2) How many devices are clean
% (:,3) How many devices have MSM infection
% (:,4) How many devices have ACM infection
% (:,5) How many devices have ACM infection neutralized
% (:,6) How many devices are on
% (:,7) How many devices are off
% (:,8) How many devices are resetting

report = zeros(1,8);
report = metrics.MakeReportsSis(report, network, param, 0);

 
%% Simulation

dk1 = 0;
dk = 0;
bk1 = 0.5;

cleaned = zeros(1, param.max_turns);
reset = zeros(1, param.max_turns);
tic;
turn = 0

disp('length of network')
length(network)

%%% SIMULATION LOGIC
%%% 
%%% 1) Since the simulation is sequential, we have to take care to avoid
%%% chain infections: a device infected this turn will effectively become
%%% an infectious device only next turn, else he may have a chance of
%%% infecting other devices this turn (chain infection).
%%% 2) To prevent this, we generate copies of "network" as an output of every
%%% process (there are 2 in this simulation: infection and cleaning).
%%% 3) After these two copies ("network_k1_infected" and "network_k1_cleaned")
%%% are generated, they are merged by the function MergeTransitions

while turn < param.max_turns
    turn = turn+1
% while (report(end,3)>0 || report(end,4)> report(end,5)) && turn < param.max_turns


%%% Infection phase. Every infected device tries to infect only one device according to Chance of Infection (alpha)
    [network_k1_infected, newInf] = infecmodels.AttackSisRandom(network, param);
    report_turn.newInfections(turn) = newInf;
%     network_k1_infected = AttackRandomNonrepeat(network, param);
%     network = network_k1_infected;


%%% Mitigate malware in devices according to Chance of Detection (beta)
    [network_k1_cleaned, cleaned_devs, reset_devs, FN, FN_M, FP] = mitigmodels.CleanSisGlobalGroup(network, param);
%   [network_k1_cleaned, cleaned_devs, reset_devs, FN, FN_M, FP, dk1, dk, bk1, G] = mitigmodels.CleanSisGlobalGroupBayes(network, param, dk1, dk, bk1);
%     [network_k1_cleaned, cleaned_devs, reset_devs, FN, FP] = CleanInfectionsSisGlobalGroupHoneypot(network, param);
    report_turn.cleanings(turn) = cleaned_devs;
    report_turn.resets(turn) = reset_devs;
    report_turn.false_neg(turn) = FN;
    report_turn.false_neg_M(turn) = FN_M;
    report_turn.false_pos(turn) = FP;
%     network = network_k1_cleaned;


%%% Merge network of transitions into the original matrix "network"
    network = simultools.MergeTransitionsSis(network, network_k1_infected, network_k1_cleaned, param.malware);

    
%%% Make a report of this turn
    report = metrics.MakeReportsSis(report, network, param, turn);
    
    
end

%% Reports and printing results into figures

report = metrics.MakeReportsSis(report, network, param, turn);

comp_time = toc
% cleaned
% reset

nameParam = strcat(datestr(now,29), '_sis_simul_a', num2str(param.alpha*100),'_b',num2str(param.beta*100),'_fpr',num2str(param.FPR*100),'_g',num2str(param.G));
plots.Plot_Sis;

savename = strcat(nameParam,'.mat');
save(savename)