
%% Initialize reports

% The matrix below is a report generated every turn about the situation of
% the network in terms of infection, device on or off.
% Every line represents a turn. The meaning of each column is:

% (:,1) Turn
% (:,2) How many devices are clean
% (:,3) How many devices have infected RAM
% (:,4) How many devices have infected ROM
% (:,5) How many devices have infected RAM and ROM
% (:,6) How many devices are on
% (:,7) How many devices are off
% (:,8) How many honeypots reports of packets received from normal devices
% (:,9) How many honeypots reports of packets received from RAM infected devices
% (:,10) How many honeypots reports of packets received from ROM infected devices
% (:,11) How many honeypots reports of packets received from RAM and ROM infected devices

report_total = zeros(param.turns+1,7);
report_total(:,1) = 0:param.turns; 
report_honeypots = zeros(param.turns+1,4);

report_normal = [];
report_infected = [];

[report_total, report_honeypots] = MakeReportsWithHP(report_total, report_honeypots, report_normal, report_infected, network, param, 0);
 
%% Simulation

report_normal = [];
report_infected = [];

tic;
for t=1:param.turns
    
%     t
    
    % Since the simulation is sequential, we have to take care to avoid
    % chain infections: before, in a single loop of "for t=1:turns",
    % device(i) could infect device(i+j) in turn i, then device(i+j) could
    % infect device(i+j+k) in turn (i+j). To prevent this, now we copy
    % "network" into "network_update", infect new devices only on 
    % "network_update" during the loop of "for sender_add=1:param.n', then after
    % this loop ends, copy "network_update" back into "network". Now if
    % device(i+j) is infected in turn i, it will not infect anyone in turn
    % (i+j). Only in the next iteration of "for t=1:turns".
    network_update = network;
    
    % Simulate a turn of communications in the IoT network
    for sender_add=1:param.n

        if (network(2,sender_add) == 1) && (network(3,sender_add) == 1)      % If device is a normal iot device and it is turned on, send message
            if (network(4, sender_add) == 0)&&(network(5, sender_add) == 0)  % If device is clean, choose a number of other devices to send clean packets
                receiver_add = GetReceiverLocal(sender_add, param.clean_packets, param, network, localGroups);
            else                                                             % If device is infected, choose a bigger number of other devices to send infected packets
                receiver_add = GetReceiverLocal(sender_add, param.infected_packets, param, network, localGroups);
            end

            % The function below does a lot of things. Check inside.
            [network, network_update, report_normal, report_infected] = SendAndProcessPacket(network, network_update, report_normal, report_infected, sender_add, receiver_add, param);
        end
        
    end
    
    network = network_update;
    
    % Reset devices that were set for resetting last turn
    network = ResetDevices(network, param);
    
    % Clean devices based on report of honeypots
    if param.server_on 
       network = CleanInfectionsLocal(network, report_infected, localGroups);
    end
    
    % Make a report of this turn
    [report_total, honeypot_reports] = MakeReportsWithHP(report_total, report_honeypots, report_normal, report_infected, network, param, t);

    % Reset reports of honeypots, because they are valid only for one turn
    report_normal = [];
    report_infected = [];
end

% network
% disp('|1.Turn||2.CleanDev|3.RamDev|4.RomDev|5.BothDev||6.On|7.Off||8.Hnormal|9.Hram|10.Hrom|11.Hboth||');
report_total

comp_time = toc

% Plottings

nameParam = strcat(strcat('sis_simul_a',num2str(param.alpha*100),'_b',num2str(param.beta*100)));
savename = strcat(nameParam,'.mat');
save(savename);